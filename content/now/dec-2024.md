+++
title = "What I am doing now, Dec 2024"
date = 2021-12-04
template = "markdown-page.html"
+++

See [previous post](@/now/may-2024.md). I have been working on [A news + AI app](https://www.newsbang.com/). It is now available on [iOS](https://apps.apple.com/us/app/newsbang-ai-news-insights/id6736856545).

The tech stack is Flutter(frontend) + Java/Spring(backend) + Golang(AI) + Postgres and S3(storage) + riverqueue(job queue) + bricksllm(LLM proxy). I worked on AI services.


## Golang for AI Service

Nowadays, AI Engineer is mostly API Engineer, where P is silent.  Stitching multiple third party API endpoint in a non-blocking manner is **possible** in Python. Doing the same thing is **simple** in Golang. I like simple things.

## Trying Out Riverqueue

[riverqueue] is a distributed job queue. It uses postgres to manage job/queue status. It is relatively new, but the core developers are experts in this problem space. I would use the same thing in my next project.

## No Frameworks

- AI frameworks: langchain/promptflow/genkit/autogen etc. 99% of **current** LLM application complexity consists of two tasks: string substitution and calling HTTP endpoints. Instead,  `text/template`+ `net/http` suffices.

- web frameworks: gin/huma/echo/fastapi etc. `net/http` suffices.

I see two added benefits:

- People of all levels can contribute. 
- Code assistance works better. Golang standard library is backward compatible; LLM spitting out a 10 years old code snippet would still work fine. When LLM generated code does not compile, 99% of the time golang language server can fix.



## What Not To Do

Uncle Bob put it like this [see full video here](https://www.youtube.com/watch?v=ecIWPzGEbFc):

> If we have made any advances in software, since 1945, it is almost entirely in **what not to do**. Structured Programming was in what not to do — don’t use unrestrained GOTO. Functional Programming — don’t use assignment. Object-Oriented Programming — don’t use pointers to functions. What we have learned over the last 70-some years is more about what not to do, than what to do. There have been no radical advances in software technology. The craft of writing software remains roughly the same as it was in 1945 — a little more modern, but not essentially any different.


Here is a 

- Using frameworks. Tech stack complexity should not exceed application complexity. 99% of **current** LLM application complexity consists of two tasks: string substitution and calling HTTP endpoints. The keyword is current because the technology is young. Building abstraction this early is premature optimization. At work I advocates using only `text/template` (or `templ` for string substitution)+ `net/http` (or `requests` for calling HTTP endpoints) for RAG workflow.

